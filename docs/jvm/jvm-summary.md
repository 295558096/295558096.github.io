# JVM 总结（一）

## 基础

### 常用命令

- `jps` 查找所有java线程。
- `jinfo -flags [port]` 查看jvm的配置信息、运行时参数。
- `jmap -heap [port]` 查看内存信息。

### JVM体系结构

- 类加载器。
- 运行时数据区
  - 程序计数器
  - 虚拟机栈
  - 本地方法栈
  - 方法区
  - 堆
- 执行引擎。

### 类加载器

- `Bootstrap Class Loader` 装载核心类库。
- `Extension Class Loader` 装载 jdk下home/lib/ext目录下的jar。
- `System Class Loader` classpath。

### 双亲委派

先从父加载器找是否已经加载了，没有加载的话，在加载Class。

### 沙箱机制

jdk的代码不被串改，保证安全。

### 反射

```java
    Class c = Foo.class;
    Class c = foo.getClass()
    Class c = Class.forName("类的相对路径");
```

### 程序计数器

- 每个线程都有一个程序计数器，是**线程私有**的。
- 指向方法区中的方法字节码。
- 当CPU进行上下文切换时，切换到该线程后，继续往下执行。

### 虚拟机栈

- 每个线程都有一个虚拟机栈，也是**线程私有**的。
- 存储的栈元素是栈帧，每调用一个方法，就会生成一个栈帧，用来存储局部变量表（入参、出参、方法内部变量）、操作数栈（记录出栈、入栈的操作）、动态链接、方法出口等信息。
- **虚拟机栈，是一个先入后出的栈。**

### 本地方法栈

- 本地方法栈与虚拟机栈类似，但是服务的对象是JVM中`native`标识的方法。

### 方法区

- 方法区主要存储的是**类信息**、**常量**、**静态变量**，是**线程共享**的。
-  jdk1.8之前，有永久代来专门存储方法区。
- jdk1.8以后，通过元空间存储。

### 堆

-  一个jvm实例只有一个堆内存，内存大小可调节。
- 被**线程共享**，存放对象实例。

### 堆空间分配

#### JDK1.8以前

- 新生代
  - eden生成区
  - s0幸存区FromSpace
  - s1幸存区ToSpace
  - 8:1:1
- 老年代。
- 永久代。

#### JDK1.8以后

- 新生代
  - eden生成区
  - s0幸存区FromSpace
  - s1幸存区ToSpace
  - 8:1:1
- 老年代
- Meta Space（元空间）
-   元空间与永久带类似，都是方法区的实现，不过元空间不在JVM中，而是使用本地内存。

### 垃圾回收策略

#### Minor GC

-  JVM 无法为一个新的对象分配空间时会触发 Minor GC。
- 回收的是eden区 + 存活区。
- 

#### Major GC

- 回收的是老年代。

#### Full GC

- 回收整个堆
- 由`Major GC`或`Full GC`触发。
  - 调用System.gc时，系统建议执行Full GC，但是不必然执行。
  - 老年代空间不足。
  - 方法区空间不足。
  - 通过Minor GC后进入老年代的平均大小大于老年代的可用内存。
  - 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

### 堆栈调用关系

- 栈 --> 堆 --> 方法区。

### 类加载顺序

1. 父静子静。
2. 父非静父构造。
3. 子非静子构造。

### Java内存模型的操作指令

- `read` 把一个变量的值从主内存传输到工作内存中。
- `load` 在 read 之后执行，把 read 得到的值放入工作内存的变量副本中。
- `use` 把工作内存中一个变量的值传递给执行引擎。
- `assign` 把一个从执行引擎接收到的值赋给工作内存的变量。
- `store` 把工作内存的一个变量的值传送到主内存中。
- `write` 在 store 之后执行，把 store 得到的值放入主内存的变量中。
- `lock` 作用于主内存的变量。
- `unlock` 解锁。

## 垃圾回收器

### 年轻代垃圾回收器

#### Serial

- 单线程垃圾回收器。
- 垃圾回收的时候，会把用户线程暂停。
- 主要用于客户端或内存特别小的情景下，效率特别高。

#### ParNew

-  是多线程的垃圾回收器。

#### Parallel Scavenge

- 又称并行垃圾回收器，是 `jdk1.7` 默认的新生代的垃圾回收器。
-  吞吐量（执行用户代码时间/执行用户代码时间+垃圾回收时间）非常高。
-  也是在暂停用户线程的情况下，进行垃圾回收，只是垃圾回收是并行的。

### 老年代垃圾回收器

#### CMS

- 并发的标记清除器。
- 清除过程
  - `初始标记` 通过GCRoot，标记存活的对象。
  - `并发标记` 可以和用户线程同时执行标记。
  - `重新标记` 在并行标记的过程中，可能会产生新的垃圾，需要重新标记。
  - `并发清理` 可以和用户线程同时执行清除。
- 优点
  - 并发收集。
  - 低停顿。
- 缺点
  - 占用CPU资源（并发收集或并发清除过程中，多线程操作cpu会上下文切换，占用CPU资源）。
  - 无法处理浮动垃圾。
  - 会产生空间碎片（标记清除算法的弊端）。

### 不区分代垃圾回收区

#### G1收集器

- 并行和并发。
  -  分代收集。
  - 空间整合。
- 步骤
  - 初始标记。
  - 分代收集。
  - 最终标记。
  - 筛选回收，通过PRT进行记账操作。

#### ZGC收集器

- jdk11 用的回收器。

## Java 四类引用

### 强引用

#### 代码

- object不会变为null

```java
Object strongRef = new Object();
Object object = strongRef;
strongRef = null;
```

#### 回收

- 作用域执行完。
- 强引用设置为null。

### 软引用

#### 代码

```java
Object softRef = new Object();
SoftReference softReference = new SoftReference(softRef);
```

#### 回收

- 内存不足的情况下，会被回收。
- 设置软引用为null。

#### 同强引用的比较

- 软引用和强引用在内存充足的情况下，都不会被回收。
- 只有在内存不足的情况下，软引用才会被回收避免OOM。

### 弱引用

#### 代码

```java
Object weakRef = new Object();
WeakReference weakReference  = new WeakReference(weakRef);
```

#### 回收

- GC执行，就会被回收。
- 设置弱引用为null。

### 虚引用

#### 代码

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj=null;
pf.get(); // 永远返回null
pf.isEnQueued(); // 返回是否从内存中已经删除
```

#### 回收

- 虚引用是每次垃圾回收的时候都会被回收，**通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用**。
- 虚引用主要用于检测对象是否已经从内存中删除。

## GC

### 垃圾的确定

#### 引用计数法

- 通过计算对象被引用的指针数量来判断是否为垃圾。

- 不能避免相互引用的问题。

#### 可达性分析

- 可避免相互引用的问题。通过与GCRoot是否能够链路可达，判断是否为垃圾对象。

- GCRoot的范畴。
  - 虚拟机栈的局部变量表所引用的对象。
  - 方法区的类属性所引用的对象。
  - 方法区的常量所引用的对象。
  - 本地方法栈所引用的对象。

### 垃圾回收算法

#### 标记清除

- 步骤
  - `标记` 从根集合开始扫描，对存活的对象进行标记。
  - `清除` 扫描整个空间，回收未标记的对象
- 优点
  - 比较简单，不需要额外空间。
- 缺点
  - 两次扫描，耗时严重。
  - 会产生内存碎片。

#### 复制算法

- 新生代的垃圾回收。
- 步骤
  - 从根集合开始，找到From中存活对象。
  - 拷贝到To内存中。
  - 然后两块内存交换身份。
- 优点
  - 没有两次扫描的过程，效率高。
  - 没有内存碎片，通过free-pointer实现快速的内存分配。
- 缺点
  - 需要双倍的空间，浪费空间。

#### 标记整理

- 步骤
  - `标记` 与标记清除算法一样。
  - `压缩` 再次扫描，并往一端滑动内存对象。
- 优点
  - 没有内存碎片，也是通过free-pointer实现的。
- 缺点
  - 需要移动对象，非常耗时。

### 内存分配策略

#### 对象创建过程

1. 优先分配Eden区。
2. 大对象直接分配到老年代。
3. 长期存活的对象，进入老年代（年龄15）。

#### 空间分配担保

-  每次minorGC之前，会判断一下，老年代中连续可用的空间，是否大于新生代所有对象的总和空间。
-  如果不大于，则会判断是否允许担保失败，允许的话，则判断老年代中最大可用空间，是否大于历次晋升到老年代对象的平均大小。
- 如果大于，则尝试进行一次minorGC，如果小于，则放弃minorGC，改为fullGC。

#### 动态年龄对象

- 如果存活空间中，相同年龄的对象大小总和大于存活空间的一半，则年龄大于等于该年龄的对象，直接进入老年代。

### 逃逸分析和栈上分配

#### 逃逸分析

- 方法内部创建的对象，再方法外部被使用。

#### 栈上分配

- 没有逃逸的对象，再栈上进行分配。
