# 《石杉架构笔记》

## volatile

### 工作内存与主内存

- 每个线程都有自己的工作内存用来存放`变量的副本`。
- `工作内存`相当于一个高速的本地缓存。
- CPU执行代码指令的时候，如果频繁从主内存加载数据，**性能**会比较差。
- 多个线程并发读写一个共享变量的时候，有可能某个线程修改了变量的值，但是其他线程不可见。

### 作用

1. `volatile`修饰的变量，当本地工作内存修改了值之后，会**强制刷新**结果回主内存，保证主内存和本地内存的数据一致性。
2. 如果此时别的线程的工作内存中有这个变量的本地缓存，会强制让**其他线程**的工作内存中的**变量缓存直接失效过期**，不允许再次读取和使用了。
3. 当另一个线程要读取本地工作内存中被修改过的值，会发现数据已经过期。线程会从主内存中加载变量的最新的值。

### 总结

- volatile主要作用是保证**可见性**以及**有序性**。
- 有序性涉及到**指令重排**、**内存屏障**等概念。
- volatile不能保证**原子性**。

## Java8对CAS性能的优化

### 问题场景

- 对于一个变量信息累加的操作，不加锁的正常情况下会出现并发问题。
- 使用`synchronized`的锁量级过重。

### Atomic原子类的底层原理

- Atomic 原子类底层用的不是传统意义的锁机制，而是无锁化的**CAS机制**，通过 CAS 机制保证多线程修改一个数值的安全性。
- CAS，`Compare and Set`，先比较再进行设置。
- 当如果在执行 CAS 的时候，发现之前获取的值跟当前的值不一样，会导致 CAS 失败，失败之后，进入一个无限循环，再次获取值，接着执行 CAS 操作。

### Java8对CAS机制的优化

- 在大量线程高并发更新原子类的时候，可能会导致大量线程空循环、自转，**性能和效率**都不是特别好。
- `LongAdder`，通过尝试使用**分段CAS**以及**自动分段迁移**的方式来大幅度提升多线程高并发执行CAS操作的性能。

#### LongAdder

- 在 Longadder 的底层实现中，首先有个 base 值，刚开始多线程来不停的累加数值，都是对 base 进行累加的。
- 接着如果发现并发更新的线程数量过多，就会开始施行分段 CAS 的机制，也就是内部会搞 Cell 数组，每个数组是一个数值分段。
- 大量的线程分别去对不同 Cell 内部的 value 值进行 CAS 累加操作，这样就把 CAS 计算压力分散到了不同的 Cell 分段数值中，降低了 CAS 计算压力。
- 如果要从 Longadder 中获取当前累加的总值，就会把 base 值和所有 Cell 分段数值加起来返回给你。
- `自动分段迁移` 如果某个 Cell 的 value 执行 CAS 失败了，那么就会自动去找另外一个 Cell 分段内的 value 值进行 CAS 操作。解決了线程空旋转、自旋不停等待执行 CAS 操作的问题，让一个线程过来执行 CAS 时可以尽快的完成这个操作。

